# -*- coding: utf-8 -*-
"""PTDLUD-04_DATH#1_Home Equity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g7R6Mx9kdzkeoNZkQeyVbWAyh4K9MV1r
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('hmeq.csv')

"""# Thống kê mô tả dữ liệu

1. Quan sát khái quát tập dữ liệu
"""

#Nhìn khái quát những dòng đầu tiên của tập dữ liệu
print('Số cột của tập dữ liệu:', df.shape[1])
print('Số dòng của tập dữ liệu:',df.shape[0])
df.head(10)

#Có thể thấy đối với cột BAD dữ liệu chỉ bao gồm 2 giá trị là 0 và 1
#Đối với cột DEBTINC, dữ liệu bị mất tương đối nhiều
#Ở dòng 3 của tập dữ liệu, dữ liệu trong dòng đó bị mất tương đối nhiều
#Đối với cột Reason, ta thấy giá trị "HomeImp" xuất hiện với tần suất lớn
#Với cột Job, ta cũng thấy giá trị "Other" cũng xuất hiện với tần suất lớn

"""2. Thống kê chi tiết về missing data"""

plt.figure(figsize=(10,8))
sns.heatmap(df.isna())
plt.show()

# Nhìn vào biểu đồ ta thấy cột DEBTINC thiếu nhiều nhất
# Những cột còn lại rải rác 1 số dữ liệu thiếu
# 2 cột BAD và LOAN không thiếu dữ liệu

df_null = df.isnull().sum()
null_percent = df_null.sum()/np.product(df.shape)*100
print('Tỉ lệ null của dữ liệu:', round(null_percent,3),'%')
print('\nThống kê giá trị null trên từng cột:\n\n',df.isnull().sum())

"""3. Kiểm tra dữ liệu trùng lắp"""

df.duplicated()

#Nhận xét: Dữ liệu không có những dòng dữ liệu trùng lắp

"""4. Mô tả khái quát dữ liệu"""

df.describe()

#Đối với cột BAD
  #Như đã đề cập dữ liệu trong cột chỉ tồn tại gồm 2 giá trị là 0 và 1
  #Dựa trên bảng thống kê ở phía trên, ta có thể thấy tới 75% giá trị của tập dữ liệu đều nhỏ hơn 0 
  #Điều đó có thể cho ta thấy giá trị 0 chiếm tỉ trọng cao tập dữ liệu. 


#Đối với cột LOAN
  #Ta thấy nhận thấy có sự chênh lệch rất lớn giữa giá trị lớn nhất và giá trị nhỏ nhất (1100 << 89900). 
  #Với độ lệch chuẩn nhỏ ta dự đoán dữ liệu sẽ không phân tán quá rộng  
  #Cùng với đó Với giá trị trung bình là 18607 và 50% dữ liệu đều nhỏ hơn 16300 
  #ta có thể nhận xét rằng dữ liệu sẽ tập trung đông xung quanh giá trị trung bình

#Đối với cột MORTDUE
  #Ta cũng nhận thấy có sự chênh lệch lớn giữa giá trị lớn nhất và giá trị nhỏ nhất (1100 << 89900)
  #Giá trị trung bình của cột là 73760 và độ lệch chuẩn không quá lớn 
  #ta dự đoán dữ liệu sẽ phân tán không quá rộng và tập trung xung quanh giá trị trung bình

#Đối với cột YOJ 
  #Tượng trưng cho số năm làm việc công việc hiện tại của KH
  #Số năm làm việc dao động trong khoảng từ 0 - 41
  #Số năm làm việc trung bình khoảng 9 năm và với độ lệch chuẩn lớn nên dữ liệu sẽ phân tán rộng

#Đối với cột DEBTINC (Debt to income)
  #Cột thể hiện tỉ lệ nợ chiếm tỉ trọng như thế nào so với thu nhập hiện tại của KH
  #Tỉ lệ dao động trong khoảng từ 0.52% - 203.31% và với giá trị trung bình là 33,78%
  #Với độ lệch chuẩn là 8,6% < giá trị trung bình nên có thể nói dữ liệu phân bố không đều

"""5. Xem phân phối của cột BAD

"""

print(df.groupby('BAD').BAD.count(),'\n')

x, y = np.unique(df['BAD'], return_counts = True)
plt.figure(figsize=(16, 8))
plt.pie(y,
        labels = x, # Nhãn của các nhóm
        colors = ['green', 'pink'], # Màu sắc của các nhóm
        autopct = '%1.1f%%', # Format hiển thị giá trị %
        shadow = False)
plt.title("Percentage of BAD", fontsize=18)

#Có thể thấy tỉ lệ KH trả được khoản vay chiếm tỉ trọng lớn hơn gấp 4 lần so với
#tỉ lệ không trả được nợ

"""6. Phân phối số tiền KH muốn vay"""

plt.figure(figsize=(16, 8))
plt.xlabel('Số tiền', fontsize=16)
df['LOAN'].plot(kind = 'hist')
plt.title("Số tiền KH muốn vay")
plt.show()

#Dữ liệu ở đây phân phối không đều và bị lệch về phía bên trái. Số tiền mà các KH muốn vay
#chiếm phần lớn từ 10000 - 30000$ và cao nhất ở khoảng 18000$

"""7. Số tiền thế chấp"""

plt.figure(figsize=(16, 8))
plt.xlabel('Số tiền thế chấp', fontsize=16)
df['MORTDUE'].plot(kind = 'hist')
plt.title("Số tiền KH thế chấp")
plt.show()

#Ta có thể thấy dữ liệu phân bố không đồng đều và bị lệch nhiều về phía bên trái. 
#Bên cạnh đó, ở biểu đồ histogram ta thấy có giá trị từ 35000 – 40000 xuất hiện riêng lẻ 
#nên rất có khả năng những giá trị này là những outlier của tập dữ liệu

"""8. **Tỉ trọng cột Job**

"""

job = df['JOB'].value_counts()
print(job,'\n')

plt.figure(figsize=(16, 8))
plt.pie(job,
        labels = job.index, # Nhãn của các nhóm
        autopct = '%1.1f%%', # Format hiển thị giá trị %
        shadow = False)
plt.title("Percentage of Job", fontsize=18)

#Ở cột Job, dữ liệu được phân thành 6 nhóm ngành nghề là ProfExe, Office, Mgr, Self
#Sales và Other và chiếm tỉ lệ không đều nhau.
#Trong đó nhóm Other chiếm tỉ trọng cao nhất (42%) và nhóm ngành Sales chiếm tỉ trọng 
#thấp nhất (1.9%)

"""9. **Tìm kiếm outlier**"""

hist_figsize = (15, 2)
binwidth = 5

f, ax = plt.subplots(1, 3, sharey=True, figsize=hist_figsize)
sns.boxplot(data=df, ax=ax[0], x='LOAN')
sns.boxplot(data=df, ax=ax[1], x='MORTDUE')
sns.boxplot(data=df, ax=ax[2], x='VALUE')
f.tight_layout()

# Nhận xét:
# Các Outlier xuất hiện rất nhiều ở 3 cột này (LOAN, MORTDUE, VALUE), nhưng vì nó mang ý nghĩa tiền bạc ==> KHÔNG CÓ GI BẤT THƯỜNG
# dữ liệu của 3 cột phân phối KHÔNG ĐỀU,  có xu hướng lệch phải

f, ax = plt.subplots(1, 2, sharey=True, figsize=hist_figsize)
sns.boxplot(data=df, ax=ax[0], x='YOJ')
sns.boxplot(data=df, ax=ax[1], x='CLAGE')
f.tight_layout()

# Các Outlier xuất hiện ở cột YOJ, nhưng vì nó mang ý nghĩa về số năm làm việc nên dù có hơn 40 năm làm việc thì cũng bình thường ==> KHÔNG CÓ GI BẤT THUONNG
# Các Outlier xuất hiện ở cột CLAGE

# dữ liệu ở cột YOJ phân phối KHÔNG ĐỀU,  có xu hướng lệch phải
# ở cột CLAGE phân phối dữ liệu không bị lệch nhiều về phía

f, ax = plt.subplots(1, 2, sharey=True, figsize=hist_figsize)
sns.boxplot(data=df, ax=ax[0], x='DEROG')
sns.boxplot(data=df, ax=ax[1], x='DELINQ')
f.tight_layout()

# Các Outlier xuất hiện ít và rải rác đều ở 2 cột này (DEROG VÀ DELINQ) ==> KHÔNG CÓ GI BẤT THƯỜNG

f, ax = plt.subplots(1, 2, sharey=True, figsize=hist_figsize)
sns.boxplot(data=df, ax=ax[0], x='NINQ')
sns.boxplot(data=df, ax=ax[1], x='CLNO')
f.tight_layout()

# Có Outlier xuất hiện ở 2 cột này (NINQ VÀ CLNO) ==> KHÔNG CÓ GI BẤT THƯỜNG
# ở 2 cột này (NINQ VÀ CLNO) phân phối dữ liệu không bị lệch nhiều về phía

f, ax = plt.subplots(figsize=hist_figsize)
sns.boxplot(data=df, ax=ax, x='DEBTINC')
f.tight_layout()
# Có Outlier xuất hiện khá nhiều ở cột DEBTINC

plt.figure(figsize=(16, 8))
plt.xlabel('Tỉ lệ', fontsize=16)
df['DEBTINC'].plot(kind = 'hist')
plt.title("Tỉ lệ nợ trên thu nhập")
plt.show()

"""10. **Histogram số năm làm việc**"""

df["YOJ"].plot.hist(bins = 40,figsize=(15,7.5))
plt.xlabel('Số năm làm việc', fontsize=16)
#Số lượng hồ sơ cho vay nhà ở nhóm người có có số năm làm việc chưa tới 1 năm chiếm tỷ lệ cao nhất với hơn 800 bộ hồ sơ
#Số lượng năm làm việc càng lớn thì số lượng hồ sơ cho vay nhà lại càng giảm

"""11. **Tỷ trọng cột Reason**"""

rea = df['REASON'].value_counts()
print(rea,'\n')
plt.figure(figsize=(16, 8))
plt.pie(rea,
        labels = rea.index, # Nhãn của các nhóm
        autopct = '%1.1f%%', # Format hiển thị giá trị %
        shadow = False)
plt.title("Percentage of reason", fontsize=18)

#Ở cột Reason: sẽ có 2 lý do chính: DebtCon, HomeImp 
#Có thể thấy tỉ lệ với lý do DebtCon chiếm tỉ trọng gấp hơn 2 lần so với lý do còn lại

"""# Làm sạch dữ liệu

1. **Xử lý missing data**

Xử lý các dòng có phần lớn dữ liệu là NULL
"""

nan_many = df[df['MORTDUE'].isna() & df['VALUE'].isna() & df['REASON'].isna() & df['JOB'].isna()]
print(nan_many.shape)
nan_many
#Show ra những điểm dữ liệu missing ở phần lớn các cột
# Ta thấy có 9 dòng có phần lớn dữ liệu ở các cột là NULL, nên ta sẽ DROP 9 dòng này

#Xóa bỏ các điểm dữ liệu trên
df.drop(index=nan_many.index, inplace = True)
df = df.reset_index(drop=True)
df[df['MORTDUE'].isna() & df['VALUE'].isna() & df['REASON'].isna() & df['JOB'].isna()]

"""REASON và JOB"""

# Ở 2 trường hợp kiểu dữ liệu là Object ( REASON và JOB )
  # (Thay thế cho giá trị có FREQ xuất hiện nhiều nhất): 
print(df[['REASON', 'JOB']].describe())

#Reason thì thay thế các giá trị NaN bằng DebtCon
#Job  thì thay thế các giá trị NaN bằng Other
df["REASON"].fillna(value = "DebtCon",inplace = True)
df["JOB"].fillna(value = "Other",inplace = True)

"""DEROG và DELINQ"""

# Trong trường hợp các cột DEROG và DELINQ, giá trị 0 xuất hiện nhiều nhất

derog = df['DEROG'].value_counts()
print(derog)
delinq = df['DELINQ'].value_counts()
print(delinq)

# thay thế các giá trị NaN ở 2 cột DEROG và DELINQ bằng giá trị 0
df["DEROG"].fillna(value=0,inplace=True)
df["DELINQ"].fillna(value=0,inplace=True)

"""CÁC CỘT CÒN LẠI"""

# Các cột còn lại sẽ thay thế bằng giá trị trung bình mean
df.fillna(value=df.mean(),inplace=True)